#include <iostream>
#include <cmath>
#include <vector>

using namespace std;

// Define a Point structure
struct Point {
    float x, y;

    Point(float _x, float _y) : x(_x), y(_y) {}

    // Print point coordinates
    void print() {
        cout << "(" << x << ", " << y << ")";
    }
};

// Function to apply scaling transformation
Point scale(Point p, float sx, float sy) {
    return Point(p.x * sx, p.y * sy);
}

// Function to apply rotation transformation about the origin
Point rotate(Point p, float angle) {
    float rad = angle * M_PI / 180.0f;  // Convert to radians
    float cosTheta = cos(rad);
    float sinTheta = sin(rad);
    
    float xNew = p.x * cosTheta - p.y * sinTheta;
    float yNew = p.x * sinTheta + p.y * cosTheta;

    return Point(xNew, yNew);
}

// Function to rotate around an arbitrary point (px, py)
Point rotateAroundPoint(Point p, float angle, float px, float py) {
    // Step 1: Translate point by (-px, -py) so that (px, py) is at the origin
    p.x -= px;
    p.y -= py;

    // Step 2: Apply rotation
    p = rotate(p, angle);

    // Step 3: Translate point back by (px, py)
    p.x += px;
    p.y += py;

    return p;
}

// Function to apply reflection across the X-axis
Point reflectX(Point p) {
    return Point(p.x, -p.y);
}

// Function to apply reflection across the Y-axis
Point reflectY(Point p) {
    return Point(-p.x, p.y);
}

// Function to apply reflection across the line y=x
Point reflectXY(Point p) {
    return Point(p.y, p.x);
}

// Function to apply transformation to a polygon (vector of points)
void applyTransformation(vector<Point>& polygon, char transformation, float param1 = 0, float param2 = 0) {
    for (auto& p : polygon) {
        switch (transformation) {
            case 'S': // Scale
                p = scale(p, param1, param2);
                break;
            case 'R': // Rotate
                p = rotate(p, param1);
                break;
            case 'A': // Rotate around arbitrary point
                p = rotateAroundPoint(p, param1, param2, param2); // param1 = angle, param2 = px, py
                break;
            case 'F': // Reflect across X-axis
                p = reflectX(p);
                break;
            case 'G': // Reflect across Y-axis
                p = reflectY(p);
                break;
            case 'H': // Reflect across line y=x
                p = reflectXY(p);
                break;
            default:
                cout << "Invalid transformation!" << endl;
                break;
        }
    }
}

// Function to display the polygon
void displayPolygon(const vector<Point>& polygon) {
    for (const auto& p : polygon) {
        p.print();
        cout << " ";
    }
    cout << endl;
}

int main() {
    vector<Point> polygon = { Point(100, 100), Point(200, 100), Point(200, 200), Point(100, 200) };
    
    cout << "Original Polygon: ";
    displayPolygon(polygon);
    
    // Apply Scaling by a factor of 2 along the X-axis and 1.5 along the Y-axis
    applyTransformation(polygon, 'S', 2.0f, 1.5f);
    cout << "Scaled Polygon: ";
    displayPolygon(polygon);

    // Apply Rotation by 45 degrees around the origin
    applyTransformation(polygon, 'R', 45);
    cout << "Rotated Polygon (45 degrees): ";
    displayPolygon(polygon);

    // Apply Rotation around an arbitrary point (150, 150) by 45 degrees
    applyTransformation(polygon, 'A', 45, 150);
    cout << "Rotated Polygon around (150, 150): ";
    displayPolygon(polygon);

    // Apply Reflection across X-axis
    applyTransformation(polygon, 'F');
    cout << "Reflected Polygon across X-axis: ";
    displayPolygon(polygon);

    // Apply Reflection across Y-axis
    applyTransformation(polygon, 'G');
    cout << "Reflected Polygon across Y-axis: ";
    displayPolygon(polygon);

    // Apply Reflection across line y=x
    applyTransformation(polygon, 'H');
    cout << "Reflected Polygon across y=x: ";
    displayPolygon(polygon);

    return 0;
}
